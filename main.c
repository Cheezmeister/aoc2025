/* ------------- Advent of Code 2025 – C23 (ISO/IEC 9899:2024) ------------- */
/*  All 12 days × 2 parts are fully written out (no macros).  */
/*  Each part currently just returns 0 – replace the body with your solution.  */
/*  Compile with:  cc -std=c23 -Wall -Wextra -O2 aoc2025.c -o aoc2025  */

/*  
 *  Originally generated by LLM from prompt:
 *    Scaffold an Advent of Code solution set in C23, formally ISO/IEC 9899:2024.
 *
 *    Stub out solutions for twelve days of 2 parts each.
 *      
 *    The puzzle input MAY be read from a file, or it MAY be read from stdin using ``` input-stdin` ``
 *    Example usage:
 *    ```console
 *    $ ./aoc2025 day 3 --input-file input.3.txt
 *    Part 1:
 *    42
 *    Complete in 0m 0s 23ms
 *    Part 2:
 *    67
 *    Complete in 24m 2s 834ms
 *    ```
 */

/*  -------------------------------------------------------------------------- */

#define _POSIX_C_SOURCE 200809L
#define _DEFAULT_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>
#include <stdint.h>
#include <errno.h>

static char** read_input_as_lines(FILE* fp)
{
  size_t capacity = 1024;
  size_t length = 0;

  char** lines = calloc(capacity , sizeof(char*));


  if (!lines) perror("calloc"), exit(EXIT_FAILURE);

  char* line = NULL;
  ssize_t n;
  unsigned int i = 0;


  while ((n = getline(&line, &length, fp)) != (ssize_t)(~0)) {
    // printf("DEBUG: %d", i);
    lines[i++] = line;
    if (i >= capacity) {
      capacity *= 2;
      lines = realloc(lines, capacity * sizeof(char*));
    }
    line = NULL;
  }

  while (i < capacity) {
    lines[i++] = NULL;
  }

  return lines;


}



/* --------------------- utility – read entire input ---------------------- */
static char *read_input(FILE *fp)
{
    size_t   total = 0;
    size_t   cap   = 1024;
    char   *buf    = malloc(cap);
    if (!buf) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    char   *line = NULL;
    size_t  n;
    while ((n = getline(&line, &cap, fp)) != (size_t)(~0)) {
        if (total + n + 1 > cap) {
            cap = (total + n + 1) * 2;
            buf = realloc(buf, cap);
            if (!buf) {
                perror("realloc");
                exit(EXIT_FAILURE);
            }
        }
        memcpy(buf + total, line, n);
        total += n;
    }
    free(line);
    buf[total] = '\0';
    return buf;
}

/* -------------------------- timing ------------------------------------- */
static double wall_time(void)
{
    struct timespec ts;
    if (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {
        perror("clock_gettime");
        return 0.0;
    }
    return ts.tv_sec + ts.tv_nsec * 1e-9;
}

/* ------------------------- day‑part function prototypes ---------------- */
int day1_part1 (const char **input);
int day1_part2 (const char **input);
int day2_part1 (const char **input);
int day2_part2 (const char **input);
int day3_part1 (const char **input);
int day3_part2 (const char **input);
int day4_part1 (const char **input);
int day4_part2 (const char **input);
int day5_part1 (const char **input);
int day5_part2 (const char **input);
int day6_part1 (const char **input);
int day6_part2 (const char **input);
int day7_part1 (const char **input);
int day7_part2 (const char **input);
int day8_part1 (const char **input);
int day8_part2 (const char **input);
int day9_part1 (const char **input);
int day9_part2 (const char **input);
int day10_part1(const char **input);
int day10_part2(const char **input);
int day11_part1(const char **input);
int day11_part2(const char **input);
int day12_part1(const char **input);
int day12_part2(const char **input);

/**
 * Day 1: Secret Entrance
 * Part 1
 */
int day1_part1(const char** input) {
  char direction = 'F';
  int count = 0;
  int total = 0;

  int dial = 50;

  for (int i = 0; input[i] != NULL; ++i) {
    const char* line = input[i];
    direction = line[0];
    sscanf(line + 1, "%d", &count);
    // printf("DEBUG: Input num %d is %p: %s", i, line, line);
    // printf("DEBUG:  Direction %c by %d\n", direction, count);

    switch (direction) {
      case 'R': dial += count; break;
      case 'L': dial += 100 - count; break;
      default: perror("Direction"); break;
    }

    // printf("DEBUG:  The dial is now %d\n", dial % 100);
    if (dial % 100 == 0)
      ++total;
  }
  return total;
}

/**
 * Day 1: Secret Entrance
 * Part 2
 */
int day1_part2(const char** input) {
  char direction = 'F';
  int count = 0;
  int total = 0;

  int dial = 50;

  for (int i = 0; input[i] != NULL; ++i) {
    const char* line = input[i];
    direction = line[0];
    sscanf(line + 1, "%d", &count);
    // printf("DEBUG: Input num %d is %p: %s", i, line, line);
    // printf("DEBUG:  Direction %c by %d\n", direction, count);

    switch (direction) {
      case 'R':
        while (count--) {
          if (++dial % 100 == 0)
            ++total;
        }
        break;
      case 'L':
        dial += 100;
        while (count--) {
          if (--dial % 100 == 0)
            ++total;
        }
        break;
      default: perror("Direction"); break;
    }

    // printf("DEBUG:  The dial is now %d\n", dial % 100);
  }
  return total;
}

int day2_part1(const char** input) { (void)input; return 0; }
int day2_part2(const char** input) { (void)input; return 0; }

int day3_part1(const char** input) { (void)input; return 0; }
int day3_part2(const char** input) { (void)input; return 0; }

int day4_part1(const char** input) { (void)input; return 0; }
int day4_part2(const char** input) { (void)input; return 0; }

int day5_part1(const char** input) { (void)input; return 0; }
int day5_part2(const char** input) { (void)input; return 0; }

int day6_part1(const char** input) { (void)input; return 0; }
int day6_part2(const char** input) { (void)input; return 0; }

int day7_part1(const char** input) { (void)input; return 0; }
int day7_part2(const char** input) { (void)input; return 0; }

int day8_part1(const char** input) { (void)input; return 0; }
int day8_part2(const char** input) { (void)input; return 0; }

int day9_part1(const char** input) { (void)input; return 0; }
int day9_part2(const char** input) { (void)input; return 0; }

int day10_part1(const char** input) { (void)input; return 0; }
int day10_part2(const char** input) { (void)input; return 0; }

int day11_part1(const char** input) { (void)input; return 0; }
int day11_part2(const char** input) { (void)input; return 0; }

int day12_part1(const char** input) { (void)input; return 0; }
int day12_part2(const char** input) { (void)input; return 0; }

/* -------------------------- dispatch table ----------------------------- */
static int (*daypart[12 * 2])(const char ** ) = {
    day1_part1, day1_part2,
    day2_part1, day2_part2,
    day3_part1, day3_part2,
    day4_part1, day4_part2,
    day5_part1, day5_part2,
    day6_part1, day6_part2,
    day7_part1, day7_part2,
    day8_part1, day8_part2,
    day9_part1, day9_part2,
    day10_part1, day10_part2,
    day11_part1, day11_part2,
    day12_part1, day12_part2
};

/* ------------------------ command‑line handling ------------------------ */
static void usage(void)
{
    fprintf(stderr,
        "Usage: %s day <N> [--input-file <path> | --input-stdin]\n"
        "  1 ≤ N ≤ 12\n"
        "  If neither option is supplied, the program reads from stdin.\n",
        "aoc2025");
    exit(EXIT_FAILURE);
}

int main(int argc, char *argv[])
{
    if (argc < 3)
        usage();

    if (strcmp(argv[1], "day") != 0)
        usage();

    int day = atoi(argv[2]);
    if (day < 1 || day > 12)
        usage();

    bool read_stdin = false;
    const char *file_path = NULL;

    for (int i = 3; i < argc; ++i) {
        if (strcmp(argv[i], "--input-stdin") == 0) {
            read_stdin = true;
        } else if (strcmp(argv[i], "--input-file") == 0) {
            if (i + 1 < argc)
                file_path = argv[++i];
            else
                usage();
        } else
            usage();
    }

    FILE *fp = NULL;
    if (read_stdin || file_path == NULL)
        fp = stdin;
    else {
        fp = fopen(file_path, "r");
        if (!fp) {
            perror("fopen");
            exit(EXIT_FAILURE);
        }
    }

    char** input = read_input_as_lines(fp);
    if (fp != stdin)
        fclose(fp);

    for (int part = 1; part <= 2; ++part) {
        int idx = (day - 1) * 2 + (part - 1);
        int (*func)(const char **) = daypart[idx];

        double start = wall_time();
        int result = func(input);
        double end = wall_time();

        printf("Part %d:\n", part);
        if (result == 0)
            printf("  [Not implemented yet]\n");
        else
            printf("  %d\n", result);
        printf("Complete in %.3f s\n", end - start);
    }

    for (int i = 0; input[i]; ++i) {
      free(input[i]);
    }

    free(input);
    return EXIT_SUCCESS;
}
